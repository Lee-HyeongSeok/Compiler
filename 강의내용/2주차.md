## **🎈 *형식 언어***

***

<br>

### **🎯 형식 언어**

> **어떤 알파벳에서 얻은 기호 상징들로 구성되는 문자열 스트림의 집합**

- **알파벳**

  > **상징(symbol)들의 유한 집합으로 정의된다.**

  - **T1** = {ㄱ, ㄴ, ㄷ, ... , ㅎ, ㅏ, ㅑ}
  - **T2** = {A, B, C, ... , Z}
  - **T3** = {auto, break, case, ... , while}

- **문자열**

  > **여러개의 상징(symbol)들을 연속적으로 이어 만드는 것**

- **길이**

  > **문자열에 존재하는 상징(symbol)의 개수를 의미하며, 오메가로 정의한다.**

  - **ω(오메가)**

- **빈 문자**

  > **아무런 심볼도 존재하지 않는 문자열을 의미하며, 앱실론 또는 람다로 표현한다.**
  >
  > 길이는 0이다.

  - **ε(앱실론)** 또는 **λ(람다)**
  - |ε| = 0, 길이가 0이다.

- **T*(티 스타)**

  > **알파벳 집합 T로부터 만들 수 있는 모든 문자열들의 집합을 의미하며, ε(앱실론)<br> 을 포함하는 무한집합이다.**

  - T*의 집합에서 언어(L, Language)가 되려면 의미를 가질 수 있어야 한다.
  - L의 범위를 어떻게 제한하는가에 따라 언어의 집합이 달라질 수 있다.
  - T*의 부분 집합(Sub Set)을 언어(L, Language)라 한다.

- **T+(티 대거)**

  > **T*에서 앱실론을 제외한 집합을 의미한다.**

  - T+ = T* - {ε}

<br>

### **🎯 형식 언어(L, Language) 정의의 문제점**

- 언어의 무한성으로 인한 표현 및 정의에 대한 문제

- **언어에 대한 유한 한 표현을 찾는 방법**

  1. 조건 제시법으로 무한집합을 표시하는 방법

  2. 문법(G, Grammar)을 이용해서 무한집합을 표시하는 방법

     - **L**이 가진 원소의 **길이(ω)**를 도출할 수 있다.
     - **G**를 이용하여 특정 언어의 규칙을 준수하는 텍스트 결과를 추출한다.

  3. 인식기(Recognizer)를 이용해서 무한집합을 표시하는 방법 

     - **G**를 이용하여 특정 언어의 규칙을 준수하는 텍스트 결과가 **G**에 부합하는지<br> 검사한다.

     - **어휘 분석기**와 **SA**는 **인식기(Recognizer)**에 속한다.

       > **어휘 분석기** : 컴파일러 내부에서 단어를 찾아내며, <br> 단어를 정수(Token Number)로 변환한다.
       >
       > **구문 분석기(SA)** : 트리 형태로 코드를 출력한다.

<br> 

### **🎯 형식 언어의 정의들**

- **컨케터네이션(concatenation) 연산**

  > **문자열 u와 v가 존재할 때 concatenation 연산을 이용하면 uv를 만들 수 있다.**

  - **ex)** **u = a1, a2, a3	v = b1, b2, b3**<br> **uv** = a1a2a3b1b2b3
  - **ex)** **uε**<br> uε = u = εu<br> 앱실론은 원소가 없기 때문에 앞뒤로 붙어도 무관하다
  - **ex) 모든 u, v가 T *에 포함되고 uv도 T * 에 포함된다.**

  - **ex) a^n은 a가 n개 나오는 것을 의미한다.**
  - **ex) a^0은 ε(앱실론)을 의미한다.**

- **a^n**

  > **a가 n개 표시되는 것을 의미한다.**

  - a^0은 ε(앱실론)이다.

- **reversal**

  > **문자열 ω를 ω^R로 나타내고 문자열을 거꾸로 나타내는 것을 의미한다.**

  - **ex) ω = a1a2a3...an**<br> ω^R = an...a3a2a1

- **Language Product**

  > **LL' = {xy| x는 L의 원소, y는 L'의 원소}**

  - 언어끼리 concatenation 연산 진행 시 xy라는 스트링이 나온다.
  - L의 원소 개수 |L| = 3, L'의 원소 개수 |L'| = 3이면 LL'은 3x3 = 9개의 원소가 나온다.

- **Power - 재귀적 승법**

  > L^0 = {ε}
  >
  > L^n = LL^(n-1), n >= 1일 때

- **L***

  > **L의 0승부터 무한 승으로 만들 수 있는 모든 조합의 집합을 의미한다.**

  - **L*** = L^0 ∪ L^1 ∪ L^2 ∪ ... ∪ L^n = L^i의 모든 집합(0 <= i <= ∞)

- **L***

  > **L *에서 L^0를 뺀 것, L * - L^0(ε)**

<br> 

### **🎯 형식 문법**

- **언어(Language)**
  - 문장들을 원소로 갖는 집합
- **문법(Grammar)**
  - 일종의 규칙 집합(Rule set)이다.
  - 일련의 규칙을 이용해서 문자열을 만들어 내는 과정을 알 수 있다.
  - ω(오메가)의 구성 요소 : 알파벳 T에 존재하는 원소로 구성
  - 문법도 알파벳 심볼들(Terminal Symbol)의 집합을 필요로 한다.
  - **문법 기호**는 **V(보카블러리)**로 표시한다.

<br> 



### **🎯 형식 문법 - Terminal, Non Terminal**

> **형식 언어를 생성하기 위한 규칙**

- **Symbol의 Terminal** : 더 이상의 추가적인 연산이나 작업이 없는 상태를 의미한다.

- **Terminal** : 정의된 언어의 알파벳이나 기호(영문자의 소문자, 아라비아 숫자, 연산자, 기호 등)
  - **Vt**(터미널 기호들의 유한집합)로 표현
- **Non Terminal** : 언어에서 문자열을 생성하는 데 사용되는 중간 과정의 기호(보통 대문자로 표시)
  - **Vn**(논터미널 기호들의 유한집합)로 표현
  - 중간 단계의 심볼 집합이다.
- **Terminal(Vt) + Non Terminal(Vn) = V**, 교집합은 존재하지 않는다.

<br> 

### **🎯 형식 문법 정의 G = (Vn, Vt, P, S)**

- **Vn** : 논터미널 기호들의 유한집합

- **Vt** : 터미널 기호들의 유한집합

  - Vn과 Vt의 교집합은 존재하지 않는다.
  - Vn + Vt는 V이다.

- **P(Production Rule Set)** : 생성규칙의 집합

  - a->b라는 직관적인 형식을 가진다.<br> a : 좌측에 위치한다 하여 **Left Hand Side(LHS)**라 한다.<br> b : 우측에 위치한다 하여 **Right Hand Side(RHS)**라 한다.

  - a->b : a는 b로 대치될 수 있음을 의미

    >  a는 V+의 원소이며 b는 V*의 원소여야 한다는 전제 조건이 존재(a는 앱실론이 있을 수 없다)

  - P는 파이프 기호인 | 로 구분해서 정리할 수 있다.

  - **P의 제한 조건** : ε(앱실론)에서 의미의 길이를 가지는 심볼이 나올 수 없다.

  - **형식 문법 4종류 [촘스키 계층구조]**

    > 생성 규칙의 형태에 가해지는 제한에 따라 촘스키는 형식 문법을 4 종류로 나눴다.

    1. Type0
    2. Type1
    3. Type2(CFG)
    4. Type3(정규문법)

- **S(Start Symbol 또는 Sentence Symbol)** : 시작 기호

  - 문자열을 만들기 위해서는 시작점이 필요하다.
  - 문장이 만들어지는 Start Position을 S로 표기
  - Vn(논터미널 기호들의 유한집합)에 속해 있는 원소 중 하나이다.

- **ex) G = ( {S, A}, {a, b}, P, S)**

  - {S, A} 는 **Vn(논터미널 기호들의 유한 집합)**
  - {a, b} 는 **Vt(터미널 기호들의 유한 집합)**

  > **P : **<br> S -> aAS   S -> a<br> A -> SbA   A -> ba   A -> SS
  >
  > **P를 파이프 기호인 | 로 구분하여 정리<br> => ** S -> aAS | a<br>        A -> SbA | ba | SS

<br> 

### **🎯 형식 문법 - 유도(Derivation)**

- **=>**
  - a -> b가 P의 원소이고, r과 d가 V*의 원소이면<br> rad => rbd로 바꿀 수 있다.
- **=> * **
  - a1, a2, a3, ... , an이 V*에 원소이며 a1 => a2 => a3 ... => an 라면<br> a1 => * an으로 바꿀 수 있다.
- **=>+**
  - 특수 조건에서 반드시 1번 이상 Derivation 한 것을 적용할 때 사용

<br> 

### **🎯 형식 언어와 문법 L(G)**

- **L** : Language, 언어
- **G** : Grammar, 문법
- **L(G)** : G(문법)로부터 만들 수 있는 L(언어)를 의미 한다.
- **L(G) = {**ω|S => * ω, ω는 Vt의 원소}
  - ω가 **Vt***에 포함된다면 **sentence, string** 이라 부른다.
  - ω가 **V***에 포함된다면 **sentential form**이라 부르며, 아직 더 처리가 필요하다.

<br> 



### **🎯 파스칼 언어 - 상수 정의 부분**

- CONST 예약어로 시작한다.
- 하나의 상수 정의는 a=b의 형태를 갖는다.
  - **a** : identifier
  - **b** : 상수를 나타내는 terminal symbol
- 상수 정의 부분은 선택적이다.
- 각각의 상수 정의는 세미콜론(;)으로 구분한다. 

<br> 

### **🎯 C언어 - 정수 선언 부분**

- **정수 선언 부분** : 여러 개의 정수 선언으로 구성된다.
  - 하나의 선언은 int a, a, a와 같은 형태를 갖는다.
  - **a** : 임의의 identifier를 나타낸다.
- 세미콜론(;)으로 각각의 선언을 구분한다.

<br> 

### **🎯 촘스키 계층 구조**

> **형식 언어**를 생성하는 **형식 문법** 들을 분류해 놓은 계층 구조

- **Type-0 문법** 
  - 모든 형식 문법을 포함한다.
  - 튜링 기계로 인식 가능한 모든 언어를 정확히 생성한다.
  - 해당 언어들은 회귀 열거 가능 언어(Recursively Enumerable Language)이다.
- **Type-1 문법**
  - **context-sensitive languages**를 생성한다.
  - 이 문법으로 묘사되는 언어는 **Non-deterministic Turing machine**으로<br> 인식 가능한 모든 언어들이다.
- **Type-2 문법**
  - **context-free languages**를 생성한다.
  - 이 언어들은 non-deterministic pushdown automaton으로 인식 가능한<br> 모든 언어들이다.
  - **context-free languages** 는 대부분의 프로그래밍 언어 문법의 이론적 기초이다.
- **Type-3 문법**
  - **regular languages** 를 생성한다.
    - search patterns와 프로그래밍 언어의 어휘구조를 정의하는데 흔히 사용된다.
  - 왼쪽에 단 하나의 non-terminal과 오른쪽에 terminal을 가지고 단 하나의 <br> non-terminal이 뒤따르도록 규칙을 제한한다.
  - 이 언어들은 **finite state automaton**으로 결정 가능한 모든 언어들이다.

