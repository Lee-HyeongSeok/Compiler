## **🎈 컴파일러 #1주차**

***

### **🎯 각 언어의 특징**

- **💻 COBOL**

  - 주로 업무용으로 사용
  - 영어식 표현 방식을 기본 구조로 취하고 있다.
  - 배우기 쉽고 작성된 프로그램을 이해하는데 용이하다.
  - 다른 프로그래밍 언어보다 상대적으로 처리 속도가 느리고 작성이 번거롭다.<br> 

- **💻 FORTRAN**

  - 알골과 함께 과학 계산용으로 사용하는 언어다.
  - 산술 기호(+, -, *, / 등)를 그대로 사용 가능하며, 수학 함수들을 호출해서 사용 가능하다.
  - C언어와 같이 범용프로그래밍 언어에 속하는 프로그래밍언어들에 비해 효율 있게 사용된다.<br> 

- **💻 ALGOL**

  - 구문 구조를 형식 문법으로 표현

    > **1. 언어의 구조와 의미가 명료하고 제어 구문 구조가 우수하다.**
    >
    > **2. 프로그램을 여러 단계의 블록으로 나누어 작성 가능한 언어의 구조를 가짐**

  - 수치 계산 절차를 표준화된 형태로 정확하게 컴퓨터에 나타내는 데 쓰이는 산술 언어다.

  - 변수의 유효 범위가 블록 내로 제한되어, 기억 장소가 절약되고 오류 가능성이 적다.<br> 

- **💻 Pascal**

  - 프로그래밍 언어론적인 관점에서 설계한 언어다.
  - 자료구조, 알고리즘과 같은 전산학적인 응용에 적합하다.
  - 자연언어를 이용한 매우 명확한 문법체계를 가지고 있다.
  - 유지 보수가 용이하다.
  - 컴파일 속도가 빠르다.<br> 

- **💻 Ada**

  - Real time Application에 적합한 언어다.
  - 이식성이 높고 신뢰성이 높은 모듈화된 프로그램의 개발이 가능하다.
  - 병렬 프로그래밍, 입출력 장치에 대한 제어 및 추상 명령, 예외 처리, 큰 프로그램을 <br> 분리하기 위한 분리 번역 기법 등을 섬세하게 포함시킨 언어다.<br> 

- **💻 C++**

  - SW의 재사용을 통해 생산성을 높이기 위한 **객체 지향 개념**을 도입한 언어다.

    > **OOPL : 클래스(Class), 상속(Inheritance), 다형성(Polymorphism)**

  - C언어의 문법적 체계를 그대로 계승했다.

  - 타임 체크를 엄격히 하여 실행 시간 오류의 가능성을 줄이고 디버깅을 돕는다.<br> 

- **💻 C#**

  - 기존의 C++과 JAVA 보다 완벽한 객체지향 언어다.
  - 편리한 인터페이스 환경을 제공한다.
  - 메모리에 대한 개발자의 부담이 감소했다(쓰레기 수집 기법)
  - 문법이 확장되었다.
  - .Net 플랫폼의 대표적인 언어로, .Net의 모든 장점을 가진다.<br> 

- **💻 JAVA** 

  - 자바 실행환경(JRE : Java Runtime Environment)이 설치된 모든 OS에서 실행 가능하다.

  - 이식성이 높은 프로그래밍 언어다.

  - 객체 지향 언어(OOPL)다.

  - 쓰레기 수집기(Garbage Collector)를 통해 메모리를 자동으로 관리한다.

    > 사용하지 않는 객체를 자동으로 제거한다.

  - 멀티쓰레드를 쉽게 구현 가능하다.

  - 동적 로딩을 지원한다.

<br> 

###  **🎯 번역기**

- **컴파일러**
  - 
- **인터프리터**
  - 사용자와 대화하듯이 코드 한 문장씩 받아서 실행
- **트랜스 레이터**
  - 대표적으로 C에 PreProcessor에서 사용한다(#include, #define... 등)



<Br> 

### **🎯 컴파일러**

**[과정]**

소스 프로그램 ->

- **어휘 분석기(Front end) - Lexical Analyzer**

  - 컴파일러 내부에서 단어를 골라낸다.
  - 어휘 분석기 없이도 구문 분석기에서 수행 가능하지만 시간적 성능이 감소한다.
  - 단어를 정수(Token Number)로 변환해준다.<br> 

- **구문 분석기(Front end) - Syntax Analyzer**

  - 트리 형태로 코드를 출력한다(Tree generation)
  - Syntax checking과 Tree generation 기능 수행<br> 

- **중간 코드 생성기(Front end) - Intermediate Code Generator**

  - 트리 형태의 코드에서 유니 코드를 생성<br>   

- **코드 최적기(Back end) - Code Optimizer**

  - 비효율적 코드를 구분해서 더 효율적인 코드로 바꾼다.

    >  **효율 = 성능, 효과 = 생산성 증가를 뜻함**

  - 실행 시간 성능 향상

  - 최적화 기법

    1. **Meaning of Optimization**
    2. **Criteria for Optimization**
    3. **Local Optimization**
    4. **Global Optimization**

    

- **기계 코드 생성기(Back end) - Target Code Generator**

  - 중간 코드로부터 기계 명령어(Machine instruction)를 생성한다.
  - 오류가 다른 문장에 영향을 미치지 않도록 수정한다 - Error Handling
  - 오류가 발생하면 복구해준다 - Error

-> 목적 프로그램

<br> 

### **🎯 컴파일러 자동화 도구**

> **N 개의 언어를 M개의 컴퓨터에서 구현하려면 N * M개의<br> 컴파일러가 필요하다.**

- **LEX**

  - 입력 스트림에서 정규표현으로 기술된 토큰들을 찾아내는 도구
  - Yacc와 같이 널리 쓰이는 어휘 분석기
  - 어휘 분석기를 읽어와서, Lexer를 만든 뒤 이를 C 언어로 만들어진 소스 코드의 형태로 출력

- **Parser Generator(PGS, Parser Generator System)**

  1. **Stanford PGS**

     - 파스칼 언어로 쓰여 있다.

     - 구문 구조를 AST 형태로 얻는다.

       > **AST(Abstract Syntax Tree) : 추상 구문 트리**
       >
       > 실제 구문에서 나타나는 모든 세세한 정보를 나타내지는 않는다.<br> 

  2. **Wisconsin PGS**

     - 파스칼 언어로 쓰여 있다.
     - Error Recovery : 에러가 다른 문장에 최대한 영향을 끼치지 않도록 수정 또는 무시 후<br> 다음 문장으로 넘어간다.
     - Error Recovery를 통해 가능한 한 번의 컴파일로 모든 에러를 검출하고자 하는 목적<br> 

  3. **YACC(Yet Another Compiler Compiler)**

     - Unix에서 수행한다.
     - C 언어로 쓰여 있다.



***

**[출처]**

[한국산업기술대학교](www.kpu.ac.kr)

[위키백과 - LEX](https://ko.wikipedia.org/wiki/Lex)

[위키백과 - 추상구문 트리](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC)

