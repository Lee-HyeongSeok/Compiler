## **🎈 *정규 언어***

***

<br> 

## <정규 문법과 정규 언어>



### **🎯 정규 언어**

- 정규 문법에 의해 생성된 언어를 정규 언어(Regular Language)라 한다.

- Token의 구조를 기술하는데 사용하는 언어
  - 토큰의 구조는 간단하기 때문에 정규 문법으로 표현 가능
  - Context-free 문법보다는 정규 문법으로 효율적인 인식기(Recognizer) 구현 가능
  - 컴파일러의 전반부를 모듈러하게 나누어 구성 가능(Scanner + Parser)
- **표현 방법**
  - 정규 문법(Regular Grammer)
  - 정규 표현(Regular Expression)
  - 유한 오토마타(Finite Automata)

<br> 

### **🎯 정규 문법**

> **문법의 생성 규칙이 우선형 형태의 규칙과 좌선형 형태의 규칙이 혼합되어<br> 있으면, 정규 문법이 아니다.**

- 생성 규칙에 따라 분류한 4가지 문법 형태 중 **(Chomsky, N) Type-3**문법이다.

- 컴파일러 어휘 분석 과정에서 인식되는 **토큰 구조**를 표현하는데 이용된다.

- 문법의 형태가 정규 문법일 때, 그 문법이 나타내는 언어의 형태를 체계적으로 구해서<br> **정규 표현**으로 나타낼 수 있다.

- **정규 문법의 형태**

  - **RLG**(우선형 문법, Right-Linear Grammer) : **nonterminal symbol**이 Terminal 뒤에 나타남

    > **A -> tB, A -> t**
    >
    > A, B ∈ Vn and t ∈ Vt*

  - **LLG**(좌선형 문법, Left-Linear Grammer) : **nonterminal symbol**이 Terminal 앞에 나타남

    > **A -> Bt, A -> t**
    >
    > A, B ∈ Vn and t ∈ Vt*

  - 모든 RLG와 LLG는 동일한 LLG, RLG T 쌍을 만들 수 있다.

  - 두 언어의 종류가 같다
  
  - **우선형, 좌선형 규칙이 혼합되어 있으면 정규 문법이 아니다.**
  
    - 정규 문법이 아닌 예시 ex)
    - G : S -> aR | c<br> R -> Sb
    - L(G) = a^n c b^n, n >= 0 : **context free 언어**
    - G : **context free 문법**

<br> 

### **🎯 정규 문법 - 우선형 문법 RLG**

> S -> abcA (우선형 문법)
>
> **변환 )** S -> aS1, S1 -> bS2, S2 -> cA로 나누는 것이 정규 문법이다.

- 우선형 문법(RLG)에서 t가 앱실론인 경우
  - 생성 규칙(production) : A -> B
    - **단일 생성 규칙(single production)**
  - 생성 규칙(production) : A -> ε
    - **ε-생성 규칙(epsilon production)**

<br>

***

## <정규 표현>



### **🎯 정규 표현이란?**

- 정규 문법 G를 대수학적인 성질로 표현
- 정규 문법 G는 문법이 나타내는 언어의 형태를 체계적으로 구하여<br> 정규 표현으로 나타낼 수 있다.
- 정규 언어에 속해있는 스트링의 모양을 직접 기술

<br> 

### **🎯 정규 표현 소자**

> 정규 표현 기본 소자 : Φ, ε, a ∈ T

- Φ : 공집합을 나타내는 정규 표현
- ε : 집합 {ε}을 나타내는 정규 표현
- terminal symbol a : 집합 {a}를 나타내는 정규 표현 

> 재귀 계산식 : +, 。, *

- ' + ' : 합집합(union)
  - (e1) + (e2) = L1 ∪ L2
- 。: 곱하기(concatenation)
  - (e1)(e2) = L1L2
- ' * ' : 차폐(closure) 
  - L* = {ε} ∪ L1 ∪ L2 ∪ L3 .. ∪ Ln

<br> 

### **🎯 정규 표현의 예**

- **ab***
  - a가 나오고 b가 0번 이상 나오는 스트링 
  - '*'는 closure로 {ε} 을 포함한 모든 원소의 합집합을 말한다.
- **(0+1)***
  - {0, 1}*
  - 0번 이상 0와 1로 이루어지는 모든 스트링 
- **(a+b)*abb**
  - a와 b로 이루어지는 모든 스트링 집합 뒤에 abb가 나오는 언어
- **(0+1)*011**
  - 0과 1로 이루어지는 모든 스트링 뒤에 011이 나오는 언어 
- **L(a)** 
  - a에 관련된 언어 L(Language)
- **L(a + b)**
  - L(a) ∪ L(b)
- **L(ab)** 
  - L(a)L(b)
- **L(a*)**
  - L(a)*
  - L(a *) = L(a) * = {ε, a, aa, aaa, ... , aaaaaaaa} = {a의 n승 | n은 0보다 크거나 같다}
  - 앱실론 ε을 포함해야 하므로 a의 n승에 n은 0이 포함되어야 한다.
- **L((aa) *(bb) *b)**
  - L((aa) *(bb) *b) = {b, ab, bb, abb, ..., aabbb} = {a의 2n승xb의 2m+1승 | n, m >= 0}
  - b가 뒤에 한번 더 붙으므로 b의 승은 홀수 개인 2m+1승이 되어야 한다.
  - n과 m은 같은 수가 나올 수는 있지만 같지는 않다.
- **L((a+b) * b (a+ab) *)**
  - L((a+b) * b (a+ab) *) = {b, ba, bab, ab, bb, aab, bbb, ...}
  - **a와 b로 이루어지는 0번 이상의 모든 스트링**과 **a와 ab로 이루어진 0번 이상의<br> 모든 스트링** 사이에 **b**가 오는 모든 언어 
- **a=b**
  - L(a) = L(b)

<br> 

### **🎯 명칭(identifier) 정규 표현**

> 특정 형태의 스트링을 표현하는데 유용하다.

- letter={A, B, C, ..., Z, a, b, c, ..., z}, digit={0, 1, 2, .., 9}<br> **letter(letter + digit)*** : letter와 digit 각 집합으로 이루어지는 모든 스트링

<br> 

### **🎯 정규 표현 - 정규 표현식**

> **계수가 정규 표현인 식을 정규 표현식이라 한다.**

- **X = aX + b**

  - a, b가 정규 표현이면 X = aX + b가 정규 표현식이다.

  - X는 **nonterminal symbol**

  - X의 우측의 식은 nonterminal이 생성하는 언어의 형태

    > **X = aX + b**
    >
    > #1) X = a(aX+b) + b     ... aX+b에 X(aX+b)를 대입
    >
    > - X = aaX+ab+b = a^2X + (ε + a)b
    > - (ε + a)b는 ab + b를 정리한 것 
    >
    > #2) X = aa(aX+b) + ab + b    ... a(aX+b) + b에 X(aX+b)를 대입
    >
    > - X = a^(k+1) X + (ε + a + aa + aaa + ... + a^k)b
    >
    > **따라서**
    >
    > (a+, a대거)b + b = ((a+, a대거) + ε)b = **a*b**
    >
    > **a, b가 정규 표현이고 L(a)이면, X=aX + b의 유일해(Unique Solution)는 a*b**
  
  <br> 

### **🎯 정규 표현식의 공리**

> **a, b, g는 정규 표현식의 대수적 속성일 때**

- a+b = b+a
- (a+b)+r = a+(b+r)
- (ab)r = a(br)
- a(b+r) = ab + ar
- (b+r)a = ba + rb
- a + a = a
- a + Φ = a, <br> **if Φ is a empty set**
- aΦ = Φ = Φa, <br>**if Φ is a empty set**
- εa = a = aε, <br> if ε is a {ε}
- a* = ε + aa* = ε + aaa* = ...
  - a가 0번 이상 이루어지는 모든 스트링 
- a* = (ε + a)* 
  - ε(앱실론)과 a로 0번 이상 이루어진 모든 스트링
- (a+ + ε ) = a*
  - a+(a대거)는 ε (앱실론)을 제외한 a로 이루어진 모든 스트링인데 ε (앱실론)을<br> 포함하므로 a*(a 스타)가 된다.
- (a*) * = a*
- a* + a = a*
  - a는 a*의 집합에 포함된다.
  - a*는 a가 0번 이상 나오는 모든 스트링을 의미한다.
- a* + a+ = a*
  - a+(a 대거)는 {ε}을 제외한 a가 1번 이상 나오는 모든 스트링이므로 a*(a 스타)의<br> 집합에 포함된다.
  - a* - a+ = {ε}
- (a+b)* = (a *b *) *
  - a*는 a가 0번 이상 나오는 모든 스트링 집합
  - b*는 b가 0번 이상 나오는 모든 스트링 집합
  - (a+b)*는 0번 이상 a와 b로 이루어지는 모든 스트링 집합 

<br>



***

## <유한 오토마타>



### **🎯 유한 오토마타(Finite Automata; FA)**

- **언어 인식기(Language Recognizer)**
  - 스트링을 받아 스트링이 그 언어의 문장인지 판별
  - 인식기 중에 가장 간단한 형태
  - 어휘 분석기의 고안 / 구현
- **FA M = (Q, ∑, δ, q0, F)**
  - Q : 상태들의 유한 집합
  - ∑ : 입력 심볼의 유한 집합
  - δ : 사상 함수(mapping function)
    - Q x ∑ -> 2 ^ Q , Q의 power set
    - δ(q, a) = {p1, p2, ..., pn}
      - q 상태에서 입력 a를 본 다음 상태는 p1부터 pn 중 하나를 선택
  - q0 : 시작 상태(start 또는 initial state)
    - Q에 포함되어야 한다(상태들의 유한 집합인 Q)
  - F : 종결 상태의 집합
    - Q에 포함되어야 한다(상태들의 유한 집합인 Q)
- **상태 전이 함수(state transition function)**
  - **⚙ 결정적 유한 오토마타(Derteministic FA; DFA)**
    - 전이 함수 δ(q, a)가 다음 상태로서 오직 한 상태만 갖는 경우
    - δ(q, a) = {p} = p
    - **DFA M** = (Q, ∑, δ, q0, F)
      - Q : 상태들의 유한 집합
      - ∑ : 입력 심볼의 유한 집합
      - δ : 사상 함수
        - Q x ∑ -> Q
        - δ(q, a) = p
          - q 상태에서 입력 a를 본 다음 상태는 p 오직 하나
      - q0 : 시작 상태
      - F : 종결 상태의 집합
    - **ex) M = ({q0, q1, q2}, {a, b}, δ, q0, {q2})**
      - 상태수 3개 : q0, q1, q2
      - 입력 심볼 : a, b
      - 시작 상태 : q0
      - 종결 상태 : q2
  - **⚙ 비결정적 유한 오토마타(Nonderteministic FA; NFA)**
    - 입력 심볼에 대한 다음 상태가 여러개 존재하는 경우
      - 전이 함수 δ(q, a)가 다음 상태로서 여러 상태를 갖는 경우
    - 다음 상태를 선택하기 위해 여러 가지 가능성을 고려
    - **NFA M**
      - Q : 상태들의 유한 집합
      - ∑ : 입력 심볼의 유한 집합
      - δ : 전이 함수
        - Q x ∑ -> 2^Q
        - δ(q, a) = {p1, p2 ..., pn}
      - q0 : 시작 상태, Q에 포함되어야 한다.
      - F : 종결 상태의 집합

### **🎯 DFA **

- **상태 전이표(transition table)**
  - FA의 전이 함수를 행렬 형태로 표현
    - 전이 함수 **확장** Q x ∑ -> Q => Q x ∑* -> Q
    - 한 개의 심볼을 스트링으로 확장
    - δ(q, xa) = δ(δ(q, x), a) 
    - ex) 상태 q0에서 스트링 aba를 인식
      - δ(q, aba) = δ(δ(δ(q, a), b), a)
    - ex) 종결 상태가 p일 때
      - δ(q0, x) = p인 경우
      - q0로부터 x를 본 다음 상태가 p 이고 p는 종결 상태에 포함되므로<br> 스트링 x는 M에 의해 인식(accept)
    - **즉, 시작 상태에서 주어진 스트링을 다 본 상태가 종결 상태이면 스트링 인식**
    - M에 의해 인식되는 언어를 **L(M)** 이라 표시
  - 행과 열에 각각 상태 집합, 입력 심볼 표시<br> 행과 열이 교차하는 위치는 다음 상태를 각각 표시
- **상태 전이도(state transition diagram)**
  - 각 상태를 노드로 표현
  - 스트링을 인식 과정을 표현한 흐름도를 말한다.
  - 스트링을 받아 들이는 인식기를 고안하는데 사용한다.
  - **상태 전이도 표현 법**
    - 전이 함수 δ(q, a) = p
      - 상태 q에서 p로 이동
      - 레이블이 a인 지시선 사용
    - 종결 상태
      - 이중 원으로 표시
    - 시작 상태
      - start 지시선으로 표시

<br> 

### **🎯 NFA**

- **상태 전이표(transition table)**

  - δ(q, a) = ∮ 

    - δ(q, a)는 정의되지 않았음
    - q 상태에서 a라는 입력 심볼이 나올 수 없음

    | 전이함수 δ |    0     |    1     |
    | :--------: | :------: | :------: |
    |     q0     | {q1, q2} | {q1, q3} |
    |     q1     | {q1, q2} | {q1, q3} |
    |     q2     |   {qf}   |    ∮     |
    |     q3     |    ∮     |   {qf}   |
    |     qf     |   {qf}   |   {qf}   |

  - NFA에 의한 전이 함수 확장

    - δ(q0, 01) = δ(q0, 0) ∪ δ(q0, 1) = {q1, q2, q3}<br> 0을 다 본 상태들에서 1을 본 상태들의 합 집합

  - NFA M 은 스트링 1011을 인식하는가?

    - δ({q0}, 1011)<br>  = δ(δ(q0, 1), 011) = δ(δ(δ(q0, 1), 0), 11) = δ(δ(δ(δ(q0, 1), 0), 1), 1)<br>  = δ(δ(δ({q1, q3}, 0), 1), 1) : q1과 q3 중에 q1 선택<br>  = δ(δ({q1, q2}, 1), 1) : 위에서 q1에서 0을 본 다음 상태는 {q1, q2} 이므로<br>  = δ({q1, q3}, 1) : 위에서 q1을 선택, q1에서 1을 본 다음 상태는 {q1, q3}<br>  = δ({q1, q3}, 1) = δ(q1, 1) ∪ δ(q3, 1) = {q1, q3, qf}<br> **종결 상태를 포함하므로 1011은  M에 의해 인식된다.**

- **상태 전이도(state transition diagram)**

  - 노드 : q0, q1, q2, q3, qf
  - 입력 심볼 : 0, 1
  - 시작 상태 : q0
  - 종결 상태 : qf
  - 전이 함수 : δ

  ![Untitled Diagram](https://user-images.githubusercontent.com/55940552/114274264-8f7c0000-9a58-11eb-8806-007a9a3bd507.png) 

<br> 

### **🎯 NFA에서 DFA로 변환**

- NFA는 언어의 구조를 쉽게 표현할 수 있지만 프로그램으로 구현이 힘듬

- DFA는 컴퓨터는 0과 1을 통해 연산이 가능하므로 0과 1에 대해 오직 하나의<br> 상태를 가지는 DFA가 프로그램으로 구현이 NFA 보다 쉽다.

- 즉, NFA에 대해 같은 언어를 인식하는 DFA 구현 가능

- ex) NFA M = ({q0, q1}, {0, 1}, δ, q0, {q1})

  - |  δ   |    0     |    1     |
    | :--: | :------: | :------: |
    |  q0  | {q0, q1} |   {q0}   |
    |  q1  |    ∮     | {q0, q1} |

  - DFA M = (Q, Σ, δ, q0, F)

    - Q : 2^Q : {{q0}, {q1}, {q0, q1}}

    - 시작 상태 : q0

    - 종결 상태 집합 F : {{q1}, {q0, q1}}

      - NFA의 종결 상태 q1을 포함하고 있는 상태들의 집합

    - 입력 심볼에 따른 전이 함수

      - δ(q0, 0) = {q0, q1}

      - δ(q0, 1) = {q0}

      - δ(q1, 0) = {∮}

      - δ(q1, 1) = {q0, q1}

      - δ({q0, q1}, 0) = δ(q0, 0) ∪ δ(q1, 0) = {q0, q1} ∪ ∮ = {q0, q1}

      - δ({q0, q1}, 1) = δ(q0, 1) ∪ δ(q1, 1) = {q0} ∪ {q0, q1} = {q0, q1}

      - 요기서 나올 수 있는 모든 상태에 이름을 A, B 등으로 변경한다(중복 제거)

      - 중복 제거한 현재 모든 상태 : {q0}, {q1}, {q0, q1}

      - {q0} = A, {q1} = B, {q0, q1} = C

      - | δ            | 0    | 1    |
        | ------------ | ---- | ---- |
        | A = {q0}     | C    | A    |
        | B = {q1}     | ∮    | C    |
        | C = {q0, q1} | C    | C    |

      - 위 표에 따른 NFA에서 DFA로 변환한 상태 전이도(B, C는 종결 상태)

      ![Untitled Diagram (1)](https://user-images.githubusercontent.com/55940552/114275637-2eefc180-9a5e-11eb-8f3e-25e28d472f07.png) 

<br> 

### **🎯  DFA 상태수 최소화** 

- DFA를 이용하는 어휘 분석기의 상태 전이표의 크기를 줄인다.
- 기억 공간을 적게 사용한다.
- 어휘 분석 프로그램을 간단히 하는데 큰 도움이 된다.
- 동치 관계(Equivalence Relation)를 해결한다
  - 상태 합침
  - 구별되지 않는 상태를 하나로 합침 
- **상태수 최소화 방법**
  - 동치 관계를 이용하여 상태수를 합친다.
  - 1. 초기의 동치 관계 구성 : 전체 상태를 종결 상태와 미종결 상태로 분할(final, nonfinal)
    2. 같은 입력 심볼에 대해 서로 다른 동치류로 가는 지시선 존재 시
       - 분할하여 새로운 동치류 구성
    3. 2번 과정을 반복해서 더 이상 분할이 일어나지 않는 경우
       - DFA M = (Q, Σ, δ, q0, F) 구성
       - 축소된 상태수 확인
       - 각 동치류에 대해 A, B, C 심볼로 표시
       - 각 심볼에 대해 입력 심볼과의 관계를 상태 전이표에 표시
       - 상태 전이도로 표시

![Untitled Diagram](https://user-images.githubusercontent.com/55940552/114293906-27b7ca80-9ad5-11eb-900f-e95a1e75eec4.png) 

<br>

***

## <정규 언어의 속성> 

### **🎯 정규 언어의 속성**

- 정규 문법, 정규 표현, 유한 오토마타와의 관계
  - 정규 문법에 대해 유한 오토마타 구성
    - 상태 집합 : Nonterminal 심볼의 집합 + 새로운 종결 상태
    - 시작 상태 : 시작 심볼
    - 사상 함수 : 전이 함수 δ
    - 정규 문법 G = (Vn, Vt, P, S), 유한 오토마타 M = (Q, Σ, δ, q0, F)

***

**[출처]**

[블로그](https://m.blog.naver.com/sjc02183/221648884997)

[한국산업기술대학교](https://portal.kpu.ac.kr/portal/default/stu)